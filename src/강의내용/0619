0619

05. 참조 타입 - 배열

    6) 배열의 특징
    : 같은 타입의 값만 관리
    : 길이를 늘리거나 줄일 수 없음.

    타입[] 변수;
    타입[] 변수 = null 초기화
    타입[] 변수 = {값0 값1 값2 값3 ...}(초기 데이터, 자동적으로 배열의 크기가 형성됨.)
    할당 : Heap에 메모리를 할당하는 키워드 new ->
    초기화 : 굳이 new의 사용없이 편의를 줌. 중괄호 안에 초기 데이터를 넣어줌

    ex) 문자열: String[] season = {"Spring", "Summer","Fall",}

    <항상 초기화는 불가능함>
    int[] scores = {83, 90, 87}; 이상적인 케이스,
    타입[]변수; (변수선언)
    변수 = { 값0 ,값1, 값2, 값3} (error) (컴파일 에러)

    변수 = new 타입 [] {값0,값1,값2,값3,..}; (크기 없이 실제 데이터를 나열)
    변수 = new 타입[5]; (데이터 없이 크기를 설정한 경우)

    String[] names = null;
    names = new String[] { "신용권", "홍길동", "감자바"}

    =/ 비슷한 케이스, 배열의 값을 넘기려고 할 때,
    void printitem(int[] scores){}

    printitem(new int[] {}) []의 안의 값은 크기, 개수?


    7) 다차원배열
    변수 [1차원인덱스][2차원인덱스]..[N차원인덱스]



1. 객체지향 프로그래밍.
    1) 정의
    객체 : 객체란 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별이 가능한 것.
    객체 : 속성과 동작으로 구성, 자바는 이러한 속성과 동작을 각각 필드와 메소드라고 부름.

    a b  c
    (속성)
    사람 : 키 성별 ..
    자동차 : 모델, cc color 등등
    (동작)(행위)
    사람의 경우 행위에 따라서 나타낼 수도 있음. methods
    속성과 동작으로 설명이 가능하며 속성은 변수로, 행위는 methods로 나타냄.
        결국, abc를 구분하는 용도로 정의를 내리는 것. 이것을 총체적으로 알 수 있는게 class



    2)객체의 상호작용
    절차보다도, 구조가 더 중요함. : 구조와 역할, 역할을 수행하기 위한 누구의 개입?

    클래스(정의 : 사람이냐 자동차냐 스택이냐 등등, 개념적인 정의이기에 실존하지는 않음)
    인스턴스(거기에 맞는 실존하는 것. 인간이라는 클래스에 실존하는 이민규, 노트북이라는 클래스에 실존하는 지금 타이밍하는 것)
    =>붕어빵 틀과 실제 제품의

    인스턴스 하나하나는 다른 값을 가지고 있지만 클래스에서 정의한 항목은 동일하게 가지고 있음.

    3)클래스 선언.
    공동적인 성격에 대한 정의를 내리는 것이다. 다른 것과의 분류, 차별화를 위한것.
    public class 클래스명 {} 클래스명은 관례상 pascal표기법을 사용함.
    $,_만 사용할 수 있음.
    4)클래스 변수
    클래스로부터 객체를 생성하려면 객체 생성 연산자인 new가 필요.
    new 연산자는 객체를 생성시키고 객체의 주소를 리턴함.
        클래스 변수 = new 클래스 ();

    (한 파일에는 한 public이 존재함. 클래스 하나당, 파일 하나로 정의해야함.)
    실행은 메인 methods가 정의되면 실행가능. 가지는 class와 가지지 않는 class로 구분. 가지는 클래스만 실행시킬 수 있다.
    크게, 메인 methods를 가지는가, 아닌가로 구별이 가능.
    없는 것은 library로 이용하기 위해 만드는 것 .
    가진 것은 사용하기 위한 것으로 만드는 것.

    생성자 필드 메소드
    필드: 객체의 데이터를 저장하는 역할, 선언 형태는 변수 선언과 비슷하지만 쓰임새가 다름.
    생성자 : new연산자로 객체를 생성할 떄 객체의 ..초기화

    (1)필드
    ex자동자를 정의 내리려고할때 필요한 정보는?
    차량, 색상, 엔진, 컬러 등등등 매우 많은 정의가 가능함. 그러나 문제만 풀 수있는 정보만 가지면 됨.
    ex)사람의 정보를 만들때 , 팔에 대한 정보만 있으면 되는가? ㄴㄴ, 사람으로 만들 수 있을 정도의 클래스가 필요함.

    public class car {
        color
        name
        speed ..

    기준에 따라서 내부냐 왜부냐를 만들 수 있음.
    필드사용. 내부외부에서 사용.
    내부에서 사용시 myCar.speed를 쓸필요없이 speed만 써도 댐.

    (2)new연산자
    지정한 클래스의 인스턴스를 heap에 만들어준다. 그리고 참조된 주소를 리턴한다.
    +하나더 있음. 생성자를 바로 호출해줌.

    car라는 instance가 만들어짐. 그안에 speed,color등등 이 변수들에 대해서 다른 초기화를 하고싶을때가  있음.
    new 클래스명

    모든 클래스는 생성자가 존재하며, 하나 이상가질 수 있음.
    모든 클래스에 생성자 선언이 없으면 컴파일러는 기본 생성자를 바이트코드 파일에 자동으로 추가.
    -> 하는 일은 없음. 매개변수없음 , 그러나 호출될 수 있겠금 보장해주는 역할을 함.
    매개변수가 없는 생성자. default 생성자.

    클래스명과 동일한 이름으로 정의하였기에 생성자 선언입니다.

    지역변수 1순위 2순위 필드변수이기에
    name = name이면 둘다 지역변수가 됨.
    이때 쓰고 싶은게 나 자신을 나타내는 것 this임.
    필드변수를 this.로 나타냄.충돌이 없다면  this.은 생략.

    alt insert누르면 입력하고 싶은 것을 만들수 있음.
    기본생성자는 select none을 하면됨. 기본 생성자가 추가됨.

    필드에 있는 내용들을 heap에 가져올 수 있음. korean생성자 코드
stack에 this가 있어서 알아서 알려주게 됨.

    생성자 오버로딩
    : 매개변수를 달리하는 생성자를 여러 개 선언하는 것.
    변수명은 중요하지 않음.




*금일 주요 세가지 키워드
1. 클래스의 구성요소 필드, 생성자 /메서드

메서드,
calc.powerOn
calc가 this가 됨. this가 이미 설정이 되어있고 그걸 통해서 호출하기 때문.
this.powerOn

정적 : 항상 존재한다. 프로그램의 시작과 종료까지 존재.
중간에 없애거나 그런거 못함. static 은 thisㄹ르 사용하지 않음. 연관된 instance가 존재하지 않기때문.

main 앞에 static이 없다면 t=new ca-example();
t.mainㅇ으로 호출
그러나 메인 methods는 JVM이 하는 것임. new의 호출은 개발자으 ㅣ책임임.\

intance초기화, 필드선언에서 하거나, 생성자에서 하거나.. 두군데가 있음.
static초기화, 값을 대입해주거나, 단순대입이 안될때는 생성자와 비슷하게 static{}정적블록사용(단순 값이 아닌 여러줄에 걸친 값일때에는)exdb초기화 network초기화시 에 사용.
